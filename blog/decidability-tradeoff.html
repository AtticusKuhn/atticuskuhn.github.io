<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@site"/><meta name="twitter:creator" content="@handle"/><meta property="og:locale" content="en_IE"/><meta property="og:site_name" content="Atticus Kuhn&#x27;s Personal Website"/><link rel="icon" href="/images/logo.png"/><title>Atticus Kuhn | The Decidability Tradeoff</title><meta name="robots" content="index,follow"/><meta name="googlebot" content="index,follow"/><meta name="description" content="There is a fine line between power and decidability"/><meta property="og:title" content="BLOG | The Decidability Tradeoff"/><meta property="og:description" content="There is a fine line between power and decidability"/><meta property="og:url" content="https://atticuskuhn.github.io/blog/decidability-tradeoff"/><meta property="og:type" content="article"/><meta property="article:published_time" content="2022-04-07T07:00:00.000Z"/><meta property="article:author" content="https://atticuskuhn.github.io"/><meta property="article:tag" content="automata"/><meta property="article:tag" content=" decidability"/><meta property="article:tag" content=" presbuger arithmetic"/><meta property="article:tag" content=" type system"/><meta property="og:image" content="/images/automata.jpeg"/><link rel="icon" href="/images/automata.jpeg"/><script type="application/ld+json">{
    "@context": "https://schema.org",
    "@type": "Blog",
    "mainEntityOfPage": {
      "@type": "WebPage",
      "@id": "https://atticuskuhn.github.io/blog/decidability-tradeoff"
    },
    "headline": "The Decidability Tradeoff",
    "image": [
      "/images/automata.jpeg"
     ],
    "datePublished": "2022-04-07T07:00:00.000Z",
    "dateModified": "2022-04-07T07:00:00.000Z",
    "author": {"@type": "Person","name": "Atticus Kuhn"},
    "description": "There is a fine line between power and decidability"
  }</script><meta name="next-head-count" content="25"/><link rel="preload" href="/_next/static/css/a60f07c92629bcf4.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a60f07c92629bcf4.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-378e68e29c265886.js" defer=""></script><script src="/_next/static/chunks/framework-91d7f78b5b4003c8.js" defer=""></script><script src="/_next/static/chunks/main-e47bb435dabe4202.js" defer=""></script><script src="/_next/static/chunks/pages/_app-58f1f96156c7d808.js" defer=""></script><script src="/_next/static/chunks/159-f71a7f919600167c.js" defer=""></script><script src="/_next/static/chunks/9-3177c4f16caaf0ef.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5Bslug%5D-635d7f1d8acf1b59.js" defer=""></script><script src="/_next/static/MYWOjH8yu_u0zBeRD6z9o/_buildManifest.js" defer=""></script><script src="/_next/static/MYWOjH8yu_u0zBeRD6z9o/_ssgManifest.js" defer=""></script><script src="/_next/static/MYWOjH8yu_u0zBeRD6z9o/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><link href="//cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0/katex.min.css" rel="stylesheet"/><div class="light"><div class="text-center flex flex-col w-full  bg-primary-100 text-primary-800"><header class="text-xl"><nav class="px-1"><a class="mx-1 px-1" href="/">Home</a> <!-- -->|<!-- --> <a class="mx-1 px-1" href="/blog">Blog</a> <!-- -->|<!-- --> <a class="mx-1 px-1" href="/projects">My Projects</a> <!-- -->|<!-- --> <a class="mx-1 px-1" href="/about">About</a> <!-- -->|<!-- --> <a class="mx-1 px-1" href="/computer-science">Computer Science</a> <!-- -->|<!-- --> <a class="mx-1 px-1" href="/math">Mathematics</a> <!-- -->|<!-- --> <a class="mx-1 px-1" href="/contact">Contact me</a> <!-- -->|<!-- --> <button class="bg-button w-fit p-3 rounded m-2 text-center text-primary-300 duration-75 undefined duration-200 hover:bg-primary-700 disabled:hover:bg-parimary-200 disabled:cursor-not-allowed">light</button></nav></header><div class="center bg-primary-200 mx-200 text-center min-h-screen p-3xl "><div class="container mx-auto flex content-center flex-col my-3xl"><h1 class="flex flex-col text-primary-900 text-4xl font-bold p-1">The Decidability Tradeoff</h1><div class="text-primary-400">There is a fine line between power and decidability</div><img alt="The Decidability Tradeoff" title="The Decidability Tradeoff" class="w-6/12 h-6/12 mx-auto" src="/images/automata.jpeg"/><div class="text-sm">By Atticus Kuhn</div><div class="text-sm">Published <!-- -->4/7/2022</div><div class="text-sm">Tags: <!-- -->automata,  decidability,  presbuger arithmetic,  type system</div></div><p class="text-justify my-3xl w-10/12 sm:w-8/12 mx-auto"><div class="markdown"><h1 class="flex flex-col text-primary-900 text-3xl font-bold p-1">What is Undecidability</h1>
<p>Like Icarus flying too close to the sun it seems that every mathematical system
will eventually be drawn towards the black hole of undecidability. Decidability
basically means there is an algorithm to answer a question. <a href="https://lisbdnet.com/what-is-standard-algorithm-addition/#:~:text=standard%20algorithm%20addition%3F-,The%20standard%20algorithm%20for%20addition%20has%20three%20simple%20rules%3A,3%3A%20Regroup%2C%20if%20necessary" node="[object Object]" class="pop rounded bg-primary-300 p-1 m-1 hover:bg-primary-100">Adding Numbers</a> is decidable but <a href="https://en.wikipedia.org/wiki/Travelling_salesman_problem" node="[object Object]" class="pop rounded bg-primary-300 p-1 m-1 hover:bg-primary-100">finding the shortest path</a> is not. In general I have noticed a pattern in
all systems of rules. The system starts off simple. Then, as more use cases pile up, more
rules and properties are added until suddenly, the system is undecidable. What happend here?
I will start with a few examples</p>
<h1 class="flex flex-col text-primary-900 text-3xl font-bold p-1">Typing Systems for Programming Languages</h1>
<p>I first encountered this problem in the type system of programming languages, or basically
an algorithm that says <code>5</code> is an integer or <code>[1,2,3]</code> is a list of integers. You may think this problem is easy, and indeed the way I have just phrased it is decidable by <a href="https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system#Algorithm_W" node="[object Object]" class="pop rounded bg-primary-300 p-1 m-1 hover:bg-primary-100">Algorithm W</a>. A type system is very useful,
but people have encountered corner cases, such as depenedent types or linear types, and they
try to extend the type system. For example, if you are trying to figure out the type of
<a href="https://en.wikipedia.org/wiki/The_C_Programming_Language" node="[object Object]" class="pop rounded bg-primary-300 p-1 m-1 hover:bg-primary-100">C</a>&#x27;s <a href="https://en.wikipedia.org/wiki/Printf_format_string" node="[object Object]" class="pop rounded bg-primary-300 p-1 m-1 hover:bg-primary-100">printf</a>, you might realise that the type of the second
argument depends on the type of the first argument.</p>
<pre><div style="color:black;background:#f5f2f0;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto"><code class="language-c" style="color:black;background:none;text-shadow:0 1px white;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span class="token" style="color:#DD4A68">printf</span><span class="token" style="color:#999">(</span><span class="token" style="color:#690">&quot;%f %s&quot;</span><span class="token" style="color:#999">,</span><span> </span><span class="token" style="color:#905">1.2</span><span class="token" style="color:#999">,</span><span> </span><span class="token" style="color:#690">&quot;hello&quot;</span><span class="token" style="color:#999">)</span></code></div></pre>
<p>If you want to encode this information into the type system, then you have just discovered
dependent types, where types depend on values. The problem of finding out if a dependently
typed program is valid is actually undecidable (as a subset of the <a href="https://en.wikipedia.org/wiki/Halting_problem" node="[object Object]" class="pop rounded bg-primary-300 p-1 m-1 hover:bg-primary-100">halting problem</a>). One you say you want this, you have stepped out
of the safety of decidable typing and you might now need to prove to the compiler
using a formal proof that a program typchecks, such as in languages such as <a href="https://www.idris-lang.org/" node="[object Object]" class="pop rounded bg-primary-300 p-1 m-1 hover:bg-primary-100">Idris</a>. A good documentation of this problem is on the website <a href="https://3fx.ch/typing-is-hard.html" node="[object Object]" class="pop rounded bg-primary-300 p-1 m-1 hover:bg-primary-100">typing is hard</a>.</p>
<p>In my view, the ideal type system of a programming language should be decidable. I don&#x27;t want
to have to write a proof that my progam is valid. The best type system for this is <a href="https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system" node="[object Object]" class="pop rounded bg-primary-300 p-1 m-1 hover:bg-primary-100">Hindley-Milner</a> which is about as far as you can creep before you plumet off the cliff of undeciability.</p>
<h1 class="flex flex-col text-primary-900 text-3xl font-bold p-1">Presbuger Arithmetic</h1>
<p>Another beautiful example of walking the tightrope of decidability is <a href="https://en.wikipedia.org/wiki/Presburger_arithmetic" node="[object Object]" class="pop rounded bg-primary-300 p-1 m-1 hover:bg-primary-100">Presburger Arithmetic</a>. Surprisingly, it is a formulation of arithmetic
where every statement is decidable by a simple algorithm. For example, you can say
<code>x+y &gt; 10</code> and the Presburger algorithm will find all satisfying x and y. What is the catch?
There is no multiplication. Presbuger Arithmetic only has plus, equals, there exists, and for all.
So statements about prime factorization, for example, are impossible to state in Presburger Arithmetic. It seems that multiplcation is intricately linked with undecidability. And
Once we say we want multiplication, arithmetic no longer becomes decidable.</p>
<h1 class="flex flex-col text-primary-900 text-3xl font-bold p-1">Undecidability is Interesting</h1>
<p>Unlike programmers, who would want decidabilty type systems, we mathematicians do <strong>not</strong>
want decidability in our systems. In truth, decidable systems are boring, and pose no
interesting mathematical questions. Due to the well-established relationship between
expressiveness and decidability, once we make a system expressive enough to pose
interesting questions, it becomes undecidable. Furthermore, in decidable systems,
truth is simply a matter of computation. If you want to check if a statement is
true, just run a computer to check it. Mathematics in decidable systems loses
all its beauty and elegance of unconventional proofs.  So maybe undeciability isn&#x27;t so bad.</p>
<h1 class="flex flex-col text-primary-900 text-3xl font-bold p-1">Walking off the Cliff</h1>
<p>What can you take away from this? Well let&#x27;s say you&#x27;re designing a programming tool like
a configuration language or a macro system. Users might demand more and more features, until,
unwittingly, your simple little tool becomes undecidable. This happened to C++ templates,
where now they are <a href="https://stackoverflow.com/questions/189172/c-templates-turing-complete" node="[object Object]" class="pop rounded bg-primary-300 p-1 m-1 hover:bg-primary-100">turing complete</a> (or in other words undecidable). So my advice is to
keep in mind the original goal of your project and be aware of any features that
might cause you to wander from the island of safety that is decidability.</p></div></p><div><div class="text-lg font-bold"> Reccomended Articles</div><div class="fl"><a href="/blog/sandeep-interview"><div class="p-sm m-base flex flex-col bg-primary-100 rounded m-lg pop max-w-xl min-h-full "><img alt="Interview with Machine Learning Expert" class="p-tiny mx-auto m-0 block h-full w-full" src="/images/sandeep.jpg"/><div class="font-bold">Interview with Machine Learning Expert</div><div class="text-primary-300 text-xs">After his 30 years in the field, machine learning engineer Sandeep Srinivasan offers advice on how to tackle this complex career.</div></div></a><a href="/blog/create-personal-site"><div class="p-sm m-base flex flex-col bg-primary-100 rounded m-lg pop max-w-xl min-h-full "><img alt="Tips for Creating a Personal Site" class="p-tiny mx-auto m-0 block h-full w-full" src="/images/personal-identity.jpg"/><div class="font-bold">Tips for Creating a Personal Site</div><div class="text-primary-300 text-xs">If you are thinking about creating a personal site, I have advice</div></div></a><a href="/blog/why-i-love-vim"><div class="p-sm m-base flex flex-col bg-primary-100 rounded m-lg pop max-w-xl min-h-full "><img alt="Why I love VIM" class="p-tiny mx-auto m-0 block h-full w-full" src="/images/vim.png"/><div class="font-bold">Why I love VIM</div><div class="text-primary-300 text-xs">Vim is arguable the best text editor</div></div></a></div></div></div><footer><hr/><span>Ⓒ all rights reserved <a href="https://atticuskuhn.github.io" class="pop rounded bg-primary-300 p-1 m-1 hover:bg-primary-100">Atticus Kuhn</a> <!-- -->2022</span></footer></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"blog":{"content":"\n\n# What is Undecidability\n\nLike Icarus flying too close to the sun it seems that every mathematical system\nwill eventually be drawn towards the black hole of undecidability. Decidability\nbasically means there is an algorithm to answer a question. [Adding Numbers](https://lisbdnet.com/what-is-standard-algorithm-addition/#:~:text=standard%20algorithm%20addition%3F-,The%20standard%20algorithm%20for%20addition%20has%20three%20simple%20rules%3A,3%3A%20Regroup%2C%20if%20necessary) is decidable but [finding the shortest path](https://en.wikipedia.org/wiki/Travelling_salesman_problem) is not. In general I have noticed a pattern in\nall systems of rules. The system starts off simple. Then, as more use cases pile up, more\nrules and properties are added until suddenly, the system is undecidable. What happend here?\nI will start with a few examples\n\n# Typing Systems for Programming Languages\n\nI first encountered this problem in the type system of programming languages, or basically\nan algorithm that says `5` is an integer or `[1,2,3]` is a list of integers. You may think this problem is easy, and indeed the way I have just phrased it is decidable by [Algorithm W](https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system#Algorithm_W). A type system is very useful,\nbut people have encountered corner cases, such as depenedent types or linear types, and they\ntry to extend the type system. For example, if you are trying to figure out the type of \n[C](https://en.wikipedia.org/wiki/The_C_Programming_Language)'s [printf](https://en.wikipedia.org/wiki/Printf_format_string), you might realise that the type of the second\nargument depends on the type of the first argument.\n\n```c\nprintf(\"%f %s\", 1.2, \"hello\")\n```\nIf you want to encode this information into the type system, then you have just discovered\ndependent types, where types depend on values. The problem of finding out if a dependently\ntyped program is valid is actually undecidable (as a subset of the [halting problem](https://en.wikipedia.org/wiki/Halting_problem)). One you say you want this, you have stepped out\nof the safety of decidable typing and you might now need to prove to the compiler\nusing a formal proof that a program typchecks, such as in languages such as [Idris](https://www.idris-lang.org/). A good documentation of this problem is on the website [typing is hard](https://3fx.ch/typing-is-hard.html).\n\nIn my view, the ideal type system of a programming language should be decidable. I don't want\nto have to write a proof that my progam is valid. The best type system for this is [Hindley-Milner](https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system) which is about as far as you can creep before you plumet off the cliff of undeciability.\n\n# Presbuger Arithmetic\n\nAnother beautiful example of walking the tightrope of decidability is [Presburger Arithmetic](https://en.wikipedia.org/wiki/Presburger_arithmetic). Surprisingly, it is a formulation of arithmetic\nwhere every statement is decidable by a simple algorithm. For example, you can say \n`x+y \u003e 10` and the Presburger algorithm will find all satisfying x and y. What is the catch?\nThere is no multiplication. Presbuger Arithmetic only has plus, equals, there exists, and for all.\nSo statements about prime factorization, for example, are impossible to state in Presburger Arithmetic. It seems that multiplcation is intricately linked with undecidability. And\nOnce we say we want multiplication, arithmetic no longer becomes decidable.\n\n# Undecidability is Interesting\n\nUnlike programmers, who would want decidabilty type systems, we mathematicians do **not**\nwant decidability in our systems. In truth, decidable systems are boring, and pose no\ninteresting mathematical questions. Due to the well-established relationship between\nexpressiveness and decidability, once we make a system expressive enough to pose\ninteresting questions, it becomes undecidable. Furthermore, in decidable systems,\ntruth is simply a matter of computation. If you want to check if a statement is \ntrue, just run a computer to check it. Mathematics in decidable systems loses\nall its beauty and elegance of unconventional proofs.  So maybe undeciability isn't so bad.\n\n# Walking off the Cliff\n\nWhat can you take away from this? Well let's say you're designing a programming tool like\na configuration language or a macro system. Users might demand more and more features, until,\nunwittingly, your simple little tool becomes undecidable. This happened to C++ templates,\nwhere now they are [turing complete](https://stackoverflow.com/questions/189172/c-templates-turing-complete) (or in other words undecidable). So my advice is to\nkeep in mind the original goal of your project and be aware of any features that\nmight cause you to wander from the island of safety that is decidability. \n\n\n","date":"April 7, 2022","tags":["automata"," decidability"," presbuger arithmetic"," type system"],"title":"The Decidability Tradeoff","slug":"decidability-tradeoff","description":"There is a fine line between power and decidability","image":"/images/automata.jpeg"},"reccomendedBlog":[{"content":"\nSandeep Srinivasan is a veteran of the machine learning industry. While most have gravitated towards it since the hype of the late 2000s, Srinivasan claims he has been “interested in machine learning since the 1990s,” almost noachian in this quickly evolving field. Today, I sat down with Srinivasan in order to glean what insights he has after pioneering this industry for 30 years. \n\nI am struck by Srinivasan’s positive attitude. He himself concurs, saying its necessary to be “a lifelong learner” to succeed in this field. Even with his experience, he is “still taking courses” to learn new skills and improve himself. His optimism extends further, however. When describing how he first got into machine learning, Srinivasan said a professor was too embarrassed that no one signed up for his course in machine learning, so he paid Srinivasan $10 an hour to be the only attendant. Despite being happenstance, Srinivasan tells the story with a smile as if it is a good joke. He brings this sense of optimism to his work, summarizing that the “best part of [his] job” is to meet bright 20-year-olds who have a “beginner’s mindset” and are eager to learn. \n\nFinding these bright 20-year-olds is becoming increasingly difficult for Srinivasan, unfortunately. In this white-hot field, he must muscle his way through the likes of “Google, Facebook, Amazon, and Apple.” Due to this drive for talent, Srinivasan complains that “the hardest part” of his job is hiring for his small machine learning startup.\n\nDespite his recruiting woes, Srinivasan claims he is not deterred about founding a small machine learning startup. He says the experience has been rewarding for him. When speaking on the advantages of founding a startup, he says he gets to “eat [his] own dog food,” in the sense that he is excited to try out all the products as a consumer that he is inventing. He emphasize that a founder must act as the first customer of a product, because if the founder doesn’t believe in the product, then neither will the clients. \n\nThe main area where Srinivasan eagerly gets to try out his new inventions is with his products aiming to “simplify machine learning.” He uses his own online dashboard to set up machine learning models in a few clicks, and soon he hopes others can do the same. His mission is to “democratize machine learning for multiple applications.”  In the future, Srinivasan imagines that doctors or other domain experts could create machine learning models without coding and without technical knowledge. \n\t\nDoctors are not the only profession Srinivasan predicts machine learning will impact. He thinks that many “repetitive tasks” such as “data entry” for taxes will disappear. In addition, manual tasks, such as image labeling will be automated away by machine learning.\n\nOverall, I am very impressed with Srinivasan’s accomplishments. He certainly has the air of someone well-informed on the industry, and he was able to use his knowledge to give me personal advice for the job market (“learn statistics”). Given how he effuses knowledge in every aspect of machine learning, I would not be surprised if his startup goes far. This experience was very informative for me, and I see myself possibly having a career in machine learning. I suggest to the reader to conduct a similar informational interview, in the hopes that one could learn about an intriguing field from a personality. \n\n\n \n","date":"Feb 27, 2022","tags":["machine learning"," interview"," coding"],"title":"Interview with Machine Learning Expert","slug":"sandeep-interview","description":"After his 30 years in the field, machine learning engineer Sandeep Srinivasan offers advice on how to tackle this complex career.","image":"/images/sandeep.jpg"},{"content":"\n\n# My Site\nAs I have created a personal site (you're looking at it right now), I feel somewhat\nqualified to give advice to others on the best way of creating a personal site. Of course,\nif you are not impressed by my personal site, feel free not to take my advice.\n\n\nSpecifically, I think I will not give the standard or obvious advice, but rather\nI will give the advice that some people need to hear, but would rather not.\n\n# Fast and Functional\n\nThis might be a personal gripe of mine, but I would caution against using website creators\nsuch as Wix or Wordpress. They just create bloat on a site that really doesn't need it.\nWhen I go to such sites, it takes forever to load because of all the javascript bundles and\ntrackers. Really, if you can be served by plain HTML, then use plain HTML. It will give\nyour users better performance and the site will load almost instantaneously. And this\nsame advice even goes for frameworks. Do you really need your technology stack\nturning into a 100 layer wedding cake just for a personal site? Many people use their\npersonal website as an excuse to try out the latest technology. I know elm/svelte/tailwind/\nwhatever might be hot right now, but sometimes the safest option is best.\n\n# Prioritze Ease-of-Use over Flashy Animations\n\nI see some portfolio websites that look like they were created as a challenge\nto use every single animation avaible in CSS. But really, all animations do is\nslow down the user. If I have to wait 300ms for this flashy animation to complete,\nthen I feel like my flow has been interrupted on this site. I want the technology\nto get in my way as little as possible. Sure, some people take animations\nas an opportunity to show off, but if you must, put the animation in a place\nwhere it doesn't interrupt the flow of the site. Also, keep the animations small\nand less that 200ms. That way, your users will not be foaming at the mouth in\nrage at this mound of useless animations.\n\n# Create Lots of Content\n\nThis advice might seem obvious, but I think it merits repeating. Creating a wealth of\ncontent has a two-fold benefit\n\n* As you write more, you will become better at writing\n\n* By writing more, you will appear higher in search engines as more people click on\nyour site.\n\nHonestly, this is why I think starting a blog is a good idea for most personal sites. \nOf course the market is over-saturated (anyone is capable of starting a blog),\nyet you can always distinguish yourself by putting in extra efforts such as writing\nlong articles\n\n\n# Takeaway\n\nI hope I have given some unconventional advice on how to start a personal site. If\nyou want to hear more about this topic, feel free to [contact me](/contact).","date":"April 7, 2022","tags":["personal site"," html"," react"," blog"," markdown blog"],"title":"Tips for Creating a Personal Site","slug":"create-personal-site","description":"If you are thinking about creating a personal site, I have advice","image":"/images/personal-identity.jpg"},{"content":"\n\nThe text editor VIM is possibly one of my favourite tools for developing and coding. Whenever I have the opportunity to use vim, from VS code to Overleaf, and even google docs, I take it. I just want more people to learn and use VIM because of what an enjoyable tool is\n\n# Macros\nMany people often waste time slaving away at menial and boring text editing tasks. Vim makes relative tasks and actions easy using macros, or repeatable sets of keystrokes. \n\n\n# Speed\nIt's no doubt that with all the keybindings, getting from one location in the text to another is usually only a few keypresses. Typing is far faster than using a mouse. I have no doubt that my coding speed has increased twofold due to Vim.\n\n\n# Efficiency\nOften when I realise I have not completed the most keystroke efficient algorithm in VIM, I undo all my changes to try again. There is something immensely satisfying about executing the proper algorithm in VIM which I strive for every time I code. \n","date":"April 12, 2021","tags":["vim"],"title":"Why I love VIM","slug":"why-i-love-vim","description":"Vim is arguable the best text editor","image":"/images/vim.png"}]},"__N_SSG":true},"page":"/blog/[slug]","query":{"slug":"decidability-tradeoff"},"buildId":"MYWOjH8yu_u0zBeRD6z9o","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>